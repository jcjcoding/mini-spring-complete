阶段一：Java 基础细节对齐
    了解了一些java的小细节，对java和c++的不同有了一些认识，方便自己从c++过渡到java为后续的阶段的学习做铺垫
    
阶段二：反射核心能力突破
按 “从基础到高阶” 的逻辑拆解反射学习，先掌握流程再解决复杂场景。第一步，学习获取 Class 对象的 3 种方式（Class.forName ()、对象.getClass ()、类名.class），对比 C++ RTTI 理解 “运行时获取类型信息” 的核心概念，通过代码测试验证不同方式的适用场景；第二步，攻克构造器操作，学会用 getConstructor ()、getDeclaredConstructor () 获取构造器，实现无参和有参实例创建，重点掌握 setAccessible (true) 突破访问权限的用法；第三步，深入私有方法与字段操作，掌握 getDeclaredField () 获取私有字段并赋值、getDeclaredMethod () 调用私有方法的完整步骤，解决 “访问权限拒绝” 的常见问题；最后，整合前序代码，形成包含 “创建实例、调用方法、操作字段” 三大核心功能的反射工具类，确保工具类能独立运行并处理基础场景。

阶段三：自定义注解实现
先理解注解本质再动手实现，避免直接陷入语法细节。首先学习元注解的核心作用：@Target 指定注解可修饰的元素（TYPE 用于类、METHOD 用于方法）、@Retention 指定注解保留到运行时（RetentionPolicy.RUNTIME，确保反射能扫描到），同时掌握注解参数定义规则（支持的类型、默认值设置方式）；接着，基于元注解分别实现 @Log 注解（含 String 类型的日志描述参数，默认值设为 “默认操作日志”）和 @Component 注解（含 String 类型的 Bean 名称参数，默认值为空）；最后，扩展反射工具类，添加注解扫描功能 —— 能扫描类上的 @Component 注解获取 Bean 名称，能扫描方法上的 @Log 注解提取日志描述，完成 “注解定义 + 反射扫描” 的联动。

阶段四：功能闭环与算法攻坚
先实现技术功能的端到端验证，再同步完成算法任务。第一步，搭建测试场景：创建带 @Component 注解的业务类（如 UserService，含 addUser ()、deleteUser () 方法），在其中 1-2 个方法上添加 @Log 注解并自定义日志描述；第二步，用反射工具类完成 “扫描 @Component 创建实例→调用带 @Log 的方法→打印注解日志” 的完整流程，验证反射与注解的联动效果，修正代码中的逻辑漏洞（如注解扫描不到、权限异常等）；同时，穿插完成 7 道 Easy 级算法题，优先选择与语言特性关联弱的数组 / 字符串类题目（如 “两数之和”“有效的括号”“反转字符串”），每道题完成后记录核心解题思路（如哈希表找目标值、栈处理括号匹配），确保算法任务不占用核心技术学习的过多时间。

阶段五：文档输出与最终复盘
先整理代码和文档，再做整体验证，确保目标全部落地。第一步，按要求整理代码目录结构，将反射工具类、注解定义文件放入 week1/reflection/，算法题代码放入 algorithm/daily/，并提交到 GitHub；第二步，编写两份核心文档：docs/week1-reflection.md 中记录 “反射调用与直接调用的效率对比”（可通过简单计时代码测试）、“Java 反射与 C++ RTTI 的差异”（如反射可动态修改字段值，RTTI 主要用于类型判断）；algorithm/topic/array-week1.md 中复盘数组 / 字符串题型的解题规律（如双指针处理数组合并、哈希表处理重复元素）；最后，重新运行所有代码，修正残留报错（如路径问题、注解参数读取异常），整理最终版代码包，确保反射工具类、注解功能、算法代码均能正常运行，达成初始目标。